# Создание Telegram бота с использованием Nest.js, GraphQL и Apollo Server

## Введение

В этой инструкции мы создаем Telegram бота с использованием Nest.js и GraphQL. Бот будет взаимодействовать с пользователями, запрашивать время сна и отправлять уведомления.

## 1. Установка необходимых библиотек

Сначала создаем новую папку для нашего проекта и переходим в неё:

```bash
mkdir telegram-bot
cd telegram-bot
```

Инициализируем новый проект Node.js:

```bash
npm init -y
```

Устанавливаем необходимые библиотеки:

```bash
npm install @nestjs/core @nestjs/common @nestjs/graphql graphql-tools graphql apollo-server-express mongoose node-telegram-bot-api
```

## 2. Создание структуры проекта

Создаем следующие файлы и папки в корне вашего проекта:

- `src/`
  - `app.module.ts`
  - `main.ts`
  - `db.ts`
  - `user.entity.ts`
  - `user.service.ts`
  - `user.resolver.ts`
  - `bot.service.ts`
  - `notification.service.ts`

## 3. Настройка подключения к MongoDB

### Файл: `db.ts`

```typescript
import { connect } from 'mongoose';

const connectDB = async () => {
  try {
    await connect('mongodb://mongo-user-mygeobot:password@195.80.51.100:27017/mygeobot', {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB подключен');
  } catch (error) {
    console.error('Ошибка подключения к MongoDB:', error.message);
    process.exit(1);
  }
};

export default connectDB;
```

## 4. Создание модели пользователя

### Файл: `user.entity.ts`

```typescript
import { ObjectType, Field } from '@nestjs/graphql';

@ObjectType()
export class User {
  @Field()
  id: string;

  @Field()
  chatId: string;

  @Field()
  firstName: string;

  @Field({ nullable: true })
  lastName?: string;

  @Field({ nullable: true })
  username?: string;

  @Field()
  createdAt: Date;

  @Field({ nullable: true })
  sleepTime?: string;
}
```

## 5. Создание сервиса пользователя

### Файл: `user.service.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { User } from './user.entity';
import { Model } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';

@Injectable()
export class UserService {
  constructor(@InjectModel('User') private userModel: Model<User>) {}

  async create(userData: Partial<User>): Promise<User> {
    const user = new this.userModel(userData);
    return user.save();
  }

  async findOne(chatId: string): Promise<User> {
    return this.userModel.findOne({ chatId });
  }

  async updateSleepTime(chatId: string, sleepTime: string): Promise<User> {
    return this.userModel.findOneAndUpdate({ chatId }, { sleepTime }, { new: true });
  }
}
```

## 6. Создание резолвера пользователя

### Файл: `user.resolver.ts`

```typescript
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql';
import { User } from './user.entity';
import { UserService } from './user.service';

@Resolver(() => User)
export class UserResolver {
  constructor(private readonly userService: UserService) {}

  @Query(() => User)
  async getUser(@Args('chatId') chatId: string): Promise<User> {
    return this.userService.findOne(chatId);
  }

  @Mutation(() => User)
  async createUser(@Args('input') input: User): Promise<User> {
    return this.userService.create(input);
  }

  @Mutation(() => User)
  async updateSleepTime(@Args('chatId') chatId: string, @Args('sleepTime') sleepTime: string): Promise<User> {
    return this.userService.updateSleepTime(chatId, sleepTime);
  }
}
```

## 7. Создание сервиса бота

### Файл: `bot.service.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { TelegramBot } from 'node-telegram-bot-api';
import { UserService } from './user.service';

@Injectable()
export class BotService {
  private bot: TelegramBot;

  constructor(private readonly userService: UserService) {
    this.bot = new TelegramBot('YOUR_TELEGRAM_BOT_TOKEN', { polling: true });
    this.initializeBot();
  }

  private initializeBot() {
    this.bot.onText(/\/sleep/, async (msg) => {
      const chatId = msg.chat.id;
      this.bot.sendMessage(chatId, 'Пожалуйста, укажите время, когда Вы обычно ложитесь спать (в формате ЧЧ:MM).');
    });

    this.bot.on('message', async (msg) => {
      const chatId = msg.chat.id;
      const sleepTimeRegex = /^\d{2}:\d{2}$/;

      if (sleepTimeRegex.test(msg.text)) {
        await this.userService.updateSleepTime(chatId.toString(), msg.text);
        this.bot.sendMessage(chatId, `Спасибо! Время когда я буду напоминать Вам ложиться спать установлено на ${msg.text}.`);
      }
    });
  }
}
```

## 8. Создание сервиса уведомлений

### Файл: `notification.service.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import { UserService } from './user.service';
import { TelegramBot } from 'node-telegram-bot-api';

@Injectable()
export class NotificationService {
  private bot: TelegramBot;

  constructor(private readonly userService: UserService) {
    this.bot = new TelegramBot('YOUR_TELEGRAM_BOT_TOKEN');
  }

  @Cron('* * * * *')
  async handleCron() {
    const users = await this.userService.findAll(); // Метод для получения всех пользователей
    const currentTime = new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

    for (const user of users) {
      if (user.sleepTime === currentTime) {
        await this.bot.sendMessage(user.chatId, `Привет, ${user.firstName}! Вам пора ложиться спать, желаю Вам приятных сновидений!`);
      }
    }
  }
}
```

## 9. Настройка основного модуля приложения

### Файл: `app.module.ts`

```typescript
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { MongooseModule } from '@nestjs/mongoose';
import { UserResolver } from './user.resolver';
import { UserService } from './user.service';
import { BotService } from './bot.service';
import { NotificationService } from './notification.service';
import { join } from 'path';

@Module({
  imports: [
    MongooseModule.forRoot('mongodb://mongo-user-mygeobot:password@195.80.51.100:27017/mygeobot'),
    GraphQLModule.forRoot({
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),
    }),
  ],
  providers: [UserResolver, UserService, BotService, NotificationService],
})
export class AppModule {}
```

## 10. Запуск приложения

### Файл: `main.ts`

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log('Бот запущен на http://localhost:3000');
}
bootstrap();
```




## Что мы получили в итоге

1. **Telegram бот**: Бот, который может принимать команды от пользователей и отправлять им сообщения.
2. **API на GraphQL**: Мы создали API, который позволяет выполнять запросы и мутации для работы с пользователями.
3. **MongoDB**: База данных для хранения информации о пользователях и их времени сна.
4. **Уведомления**: Бот отправляет уведомления пользователям в заданное время.

## Как это работает

1. **Подключение к MongoDB**: Мы используем библиотеку Mongoose для подключения к базе данных MongoDB, где храним информацию о пользователях.
2. **Создание модели пользователя**: Мы определяем модель пользователя с полями, такими как `chatId`, `firstName`, `lastName`, `username`, `createdAt` и `sleepTime`.
3. **Резолверы GraphQL**: Мы создаем резолверы для обработки запросов и мутаций, таких как получение пользователя и создание нового пользователя.
4. **Сервис бота**: Бот обрабатывает команды от пользователей и сохраняет их время сна в базе данных.
5. **Сервис уведомлений**: Каждую минуту сервис проверяет текущее время и отправляет уведомления пользователям, если время совпадает с их временем сна.

## Документация к GraphQL

Для создания документации к GraphQL API можно использовать такие инструменты, как GraphQL Playground или Apollo Studio. Они автоматически генерируют документацию на основе схемы GraphQL.

### Пример документации для методов API

1. **Query: getUser**
  - **Описание**: Получает пользователя по `chatId`.
  - **Аргументы**:
    - `chatId`: ID чата пользователя (тип: String).
  - **Возвращает**: Объект пользователя.

2. **Mutation: createUser**
  - **Описание**: Создает нового пользователя.
  - **Аргументы**:
    - `input`: Объект с данными пользователя (тип: User).
  - **Возвращает**: Созданный объект пользователя.

3. **Mutation: updateSleepTime**
  - **Описание**: Обновляет время сна пользователя.
  - **Аргументы**:
    - `chatId`: ID чата пользователя (тип: String).
    - `sleepTime`: Новое время сна (тип: String).
  - **Возвращает**: Объект пользователя с обновленным временем сна.

## Комментарии к коду

### Файл: `db.ts`

```typescript
import { connect } from 'mongoose'; // Импортируем функцию connect из mongoose

const connectDB = async () => { // Создаем асинхронную функцию для подключения к базе данных
  try {
    await connect('mongodb://mongo-user-mygeobot:password@195.80.51.100:27017/mygeobot', { // Подключаемся к MongoDB по указанному URL
      useNewUrlParser: true, // Используем новый парсер URL
      useUnifiedTopology: true, // Используем новую топологию подключения
    });
    console.log('MongoDB подключен'); // Выводим сообщение об успешном подключении
  } catch (error) {
    console.error('Ошибка подключения к MongoDB:', error.message); // Обрабатываем ошибки подключения
    process.exit(1); // Завершаем процесс при ошибке
  }
};

export default connectDB; // Экспортируем функцию подключения
```

### Файл: `user.entity.ts`

```typescript
import { ObjectType, Field } from '@nestjs/graphql'; // Импортируем декораторы ObjectType и Field из @nestjs/graphql

@ObjectType() // Определяем класс как объект GraphQL
export class User { // Создаем класс User
  @Field() // Определяем поле chatId как поле GraphQL
  chatId: string; // Присваиваем тип String

  @Field() // Определяем поле firstName как поле GraphQL
  firstName: string; // Присваиваем тип String

  @Field({ nullable: true }) // Определяем поле lastName как поле GraphQL, которое может быть null
  lastName?: string; // Присваиваем тип String

  @Field({ nullable: true }) // Определяем поле username как поле GraphQL, которое может быть null
  username?: string; // Присваиваем тип String

  @Field() // Определяем поле createdAt как поле GraphQL
  createdAt: Date; // Присваиваем тип Date

  @Field({ nullable: true }) // Определяем поле sleepTime как поле GraphQL, которое может быть null
  sleepTime?: string; // Присваиваем тип String
}
```

### Файл: `user.service.ts`

```typescript
import { Injectable } from '@nestjs/common'; // Импортируем декоратор Injectable из @nestjs/common
import { User } from './user.entity'; // Импортируем сущность User
import { Model } from 'mongoose'; // Импортируем интерфейс Model из mongoose
import { InjectModel } from '@nestjs/mongoose'; // Импортируем декоратор InjectModel из @nestjs/mongoose

@Injectable() // Декорируем класс как сервис
export class UserService { // Создаем класс UserService
  constructor(@InjectModel('User') private userModel: Model<User>) {} // Внедряем модель User

  async create(userData: Partial<User>): Promise<User> { // Создаем асинхронный метод для создания пользователя
    const user = new this.userModel(userData); // Создаем новый объект пользователя
    return user.save(); // Сохраняем пользователя в базе данных
  }

  async findOne(chatId: string): Promise<User> { // Создаем асинхронный метод для поиска пользователя по chatId
    return this.userModel.findOne({ chatId }); // Возвращаем найденного пользователя
  }

  async updateSleepTime(chatId: string, sleepTime: string): Promise<User> { // Создаем асинхронный метод для обновления времени сна
    return this.userModel.findOneAndUpdate({ chatId }, { sleepTime }, { new: true }); // Обновляем время сна и возвращаем обновленного пользователя
  }
}
```

### Файл: `user.resolver.ts`

```typescript
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql'; // Импортируем необходимые декораторы из @nestjs/graphql
import { User } from './user.entity'; // Импортируем сущность User
import { UserService } from './user.service'; // Импортируем сервис UserService

@Resolver(() => User) // Декорируем класс как резолвер для User
export class UserResolver { // Создаем класс UserResolver
  constructor(private readonly userService: UserService) {} // Внедряем сервис UserService

  @Query(() => User) // Определяем Query для получения пользователя
  async getUser(@Args('chatId') chatId: string): Promise<User> { // Создаем асинхронный метод для получения пользователя по chatId
    return this.userService.findOne(chatId); // Возвращаем найденного пользователя
  }

  @Mutation(() => User) // Определяем Mutation для создания пользователя
  async createUser(@Args('input') input: User): Promise<User> { // Создаем асинхронный метод для создания пользователя
    return this.userService.create(input); // Возвращаем созданного пользователя
  }

  @Mutation(() => User) // Определяем Mutation для обновления времени сна
  async updateSleepTime(@Args('chatId') chatId: string, @Args('sleepTime') sleepTime: string): Promise<User> { // Создаем асинхронный метод для обновления времени сна
    return this.userService.updateSleepTime(chatId, sleepTime); // Возвращаем обновленного пользователя
  }
}
```

### Файл: `bot.service.ts`

```typescript
import { Injectable } from '@nestjs/common'; // Импортируем декоратор Injectable из @nestjs/common
import { TelegramBot } from 'node-telegram-bot-api'; // Импортируем библиотеку для работы с Telegram API
import { UserService } from './user.service'; // Импортируем сервис UserService

@Injectable() // Декорируем класс как сервис
export class BotService { // Создаем класс BotService
  private bot: TelegramBot; // Объявляем переменную для бота

  constructor(private readonly userService: UserService) { // Внедряем сервис UserService
    this.bot = new TelegramBot('YOUR_TELEGRAM_BOT_TOKEN', { polling: true }); // Создаем экземпляр бота с токеном
    this.initializeBot(); // Вызываем метод инициализации бота
  }

  private initializeBot() { // Создаем метод для инициализации бота
    this.bot.onText(/\/sleep/, async (msg) => { // Обрабатываем команду /sleep
      const chatId = msg.chat.id; // Получаем ID чата
      this.bot.sendMessage(chatId, 'Пожалуйста, укажите время, когда Вы обычно ложитесь спать (в формате ЧЧ:MM).'); // Запрашиваем время сна
    });

    this.bot.on('message', async (msg) => { // Обрабатываем входящие сообщения
      const chatId = msg.chat.id; // Получаем ID чата
      const sleepTimeRegex = /^\d{2}:\d{2}$/; // Регулярное выражение для проверки формата времени

      if (sleepTimeRegex.test(msg.text)) { // Проверяем, соответствует ли введенное время формату
        await this.userService.updateSleepTime(chatId.toString(), msg.text); // Обновляем время сна в базе данных
        this.bot.sendMessage(chatId, `Спасибо! Время когда я буду напоминать Вам ложиться спать установлено на ${msg.text}.`); // Подтверждаем сохранение времени
      }
    });
  }
}
```

### Файл: `notification.service.ts`

```typescript
import { Injectable } from '@nestjs/common'; // Импортируем декоратор Injectable из @nestjs/common
import { Cron } from '@nestjs/schedule'; // Импортируем декоратор Cron из @nestjs/schedule
import { UserService } from './user.service'; // Импортируем сервис UserService
import { TelegramBot } from 'node-telegram-bot-api'; // Импортируем библиотеку для работы с Telegram API

@Injectable() // Декорируем класс как сервис
export class NotificationService { // Создаем класс NotificationService
  private bot: TelegramBot; // Объявляем переменную для бота

  constructor(private readonly userService: UserService) { // Внедряем сервис UserService
    this.bot = new TelegramBot('YOUR_TELEGRAM_BOT_TOKEN'); // Создаем экземпляр бота с токеном
  }

  @Cron('* * * * *') // Запускаем метод каждую минуту
  async handleCron() { // Создаем асинхронный метод для обработки уведомлений
    const users = await this.userService.findAll(); // Получаем всех пользователей из базы данных
    const currentTime = new Date().toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }); // Получаем текущее время в формате ЧЧ:MM

    for (const user of users) { // Перебираем всех пользователей
      if (user.sleepTime === currentTime) { // Проверяем, совпадает ли текущее время с временем сна
        await this.bot.sendMessage(user.chatId, `Привет, ${user.firstName}! Вам пора ложиться спать, желаю Вам приятных сновидений!`); // Отправляем уведомление
      }
    }
  }
}
```

### Файл: `app.module.ts`

```typescript
import { Module } from '@nestjs/common'; // Импортируем декоратор Module из @nestjs/common
import { GraphQLModule } from '@nestjs/graphql'; // Импортируем GraphQLModule из @nestjs/graphql
import { MongooseModule } from '@nestjs/mongoose'; // Импортируем MongooseModule из @nestjs/mongoose
import { UserResolver } from './user.resolver'; // Импортируем резолвер UserResolver
import { UserService } from './user.service'; // Импортируем сервис UserService
import { BotService } from './bot.service'; // Импортируем сервис BotService
import { NotificationService } from './notification.service'; // Импортируем сервис NotificationService
import { join } from 'path'; // Импортируем функцию join из path

@Module({ // Декорируем класс как модуль
  imports: [
    MongooseModule.forRoot('mongodb://mongo-user-mygeobot:password@195.80.51.100:27017/mygeobot'), // Подключаемся к MongoDB
    GraphQLModule.forRoot({ // Настраиваем GraphQL
      autoSchemaFile: join(process.cwd(), 'src/schema.gql'), // Автоматическая генерация схемы
    }),
  ],
  providers: [UserResolver, UserService, BotService, NotificationService], // Указываем провайдеров
})
export class AppModule {} // Экспортируем класс AppModule
```

### Файл: `main.ts`

```typescript
import { NestFactory } from '@nestjs/core'; // Импортируем функцию NestFactory из @nestjs/core
import { AppModule } from './app.module'; // Импортируем основной модуль приложения

async function bootstrap() { // Создаем асинхронную функцию для запуска приложения
  const app = await NestFactory.create(AppModule); // Создаем экземпляр приложения
  await app.listen(3000); // Запускаем приложение на порту 3000
  console.log('Бот запущен на http://localhost:3000'); // Выводим сообщение о запуске
}
bootstrap(); // Вызываем функцию для запуска приложения

```

## Заключение

Теперь у нас есть Telegram бот, который приветствует пользователей, запрашивает время, когда они обычно ложатся спать, и отправляет им уведомления "Вам пора ложиться спать" каждый раз, когда наступает время сна. Мы использовали Nest.js и GraphQL для создания API, а также Apollo Server для обработки запросов.
