# Инструкция по созданию приложения с использованием Socket.io и Telegram Bot API с авторизацией на web-странице по паролю и jwt-токену

## Шаг 1: Установка необходимых пакетов

1. Создаем новую директорию для вашего проекта и переходим в нее:

   ```bash
   mkdir telegram-app-jwt
   cd telegram-app-jwt
   ```

2. Инициализируем проект и устанавливаем необходимые пакеты:

   ```bash
   npm init -y
   npm install express socket.io node-telegram-bot-api mongoose passport passport-jwt jsonwebtoken bcryptjs
   ```

## Шаг 2: Создание модели пользователя

Создаем файл `User.js` для определения схемы пользователя:

```javascript
const mongoose = require('mongoose'); // Подключаем библиотеку mongoose

// Определяем схему пользователя
const userSchema = new mongoose.Schema({
    chatId: {
        type: String,
        required: true,
        unique: true, // Уникальный идентификатор для каждого пользователя
    },
    firstName: {
        type: String,
        required: true, // Обязательное поле
    },
    lastName: {
        type: String,
        required: false, // Необязательное поле
    },
    username: {
        type: String,
        required: false, // Необязательное поле
    },
    password: {
        type: String,
        required: true, // Обязательное поле для хранения пароля
    },
    createdAt: {
        type: Date,
        default: Date.now, // Дата создания по умолчанию
    },
});

const User = mongoose.model('User', userSchema); // Создаем модель на основе схемы

module.exports = User; // Экспортируем модель пользователя
``````


## Шаг 3: Создание сервера

Создаем файл `server.js` и добавляем следующий код:

```javascript
const TELEGRAM_TOKEN = 'token'; // Заменяем на наш токен
const MONGO_pwd = 'mongodb://mongo-user-mygeobot:password@195.80.51.100:27017/mygeobot';

// server.js
const express = require('express'); // Подключаем библиотеку express
const http = require('http'); // Подключаем библиотеку http для создания сервера
const socketIo = require('socket.io'); // Подключаем библиотеку socket.io для работы с веб-сокетами
const TelegramBot = require('node-telegram-bot-api'); // Подключаем библиотеку для работы с Telegram API
const mongoose = require('mongoose'); // Подключаем библиотеку mongoose для работы с MongoDB
const bcrypt = require('bcryptjs'); // Подключаем библиотеку bcrypt для хеширования паролей
const jwt = require('jsonwebtoken'); // Подключаем библиотеку jsonwebtoken для работы с JWT
const passport = require('passport'); // Подключаем библиотеку passport для аутентификации
const User = require('./User'); // Подключаем модель пользователя
const { Strategy, ExtractJwt } = require('passport-jwt'); // Импортируем стратегию и метод извлечения JWT
const path = require('path'); // Подключаем библиотеку path для работы с путями файлов

const app = express(); // Создаем экземпляр приложения express
const server = http.createServer(app); // Создаем HTTP сервер
const io = socketIo(server); // Инициализируем socket.io


const bot = new TelegramBot(TELEGRAM_TOKEN, { polling: true }); // Создаем экземпляр бота

// Подключение к MongoDB
mongoose.connect(MONGO_pwd, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => {
    console.log('MongoDB подключен'); // Выводим сообщение об успешном подключении
}).catch(err => {
    console.error('Ошибка подключения к MongoDB:', err.message); // Обрабатываем ошибки подключения
});

// Настройка стратегии Passport для JWT
const opts = {
    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Извлекаем JWT из заголовка
    secretOrKey: 'your_jwt_secret', // Замените на ваш секретный ключ
};

// Настраиваем стратегию аутентификации
passport.use(new Strategy(opts, async (jwt_payload, done) => {
    try {
        const user = await User.findById(jwt_payload.id); // Ищем пользователя по ID из JWT
        if (user) {
            return done(null, user); // Если пользователь найден, возвращаем его
        }
        return done(null, false); // Если пользователь не найден, возвращаем false
    } catch (error) {
        return done(error, false); // Обрабатываем ошибки
    }
}));

app.use(express.json()); // Используем middleware для обработки JSON
app.use(passport.initialize()); // Инициализируем passport

// Обслуживание статических файлов из папки public
app.use(express.static(path.join(__dirname, 'public'))); // Указываем папку для статических файлов

// Обработка корневого маршрута
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html')); // Отправляем файл index.html
});

// Обработка команды /start
bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id; // Получаем ID чата
    const name = msg.from.first_name; // Получаем имя пользователя
    const lastName = msg.from.last_name; // Получаем фамилию пользователя
    const username = msg.from.username; // Получаем ник пользователя

    // Проверяем, существует ли пользователь в базе данных
    const existingUser = await User.findOne({ chatId: chatId.toString() });

    // Генерируем случайный пароль
    const randomPassword = Math.random().toString(36).slice(-8); // Генерируем случайный пароль длиной 8 символов
    const hashedPassword = await bcrypt.hash(randomPassword, 10); // Хешируем пароль с помощью bcrypt

    if (!existingUser) {
        // Сохраняем нового пользователя в базе данных
        await User.create({
            chatId: chatId.toString(),
            firstName: name,
            lastName: lastName,
            username: username,
            password: hashedPassword, // Сохраняем хешированный пароль
        });
        // Отправляем случайный пароль пользователю
        bot.sendMessage(chatId, `Добро пожаловать! Ваш пароль: ${randomPassword}`); // 
    } else {
        // Если пользователь уже существует, обновляем его пароль
        await User.findOneAndUpdate(
            { chatId: chatId.toString() },
            { password: hashedPassword } // Обновляем хешированный пароль
        );
        // Отправляем случайный пароль пользователю
        bot.sendMessage(chatId, `Ваш новый пароль: ${randomPassword}`); // Отправляем пароль пользователю
    }




});

// Обработка сообщений от Telegram
bot.on('message', async (msg) => {
    const chatId = msg.chat.id; // Получаем ID чата
    const name = msg.from.first_name; // Получаем имя пользователя
    const lastName = msg.from.last_name; // Получаем фамилию пользователя
    const username = msg.from.username; // Получаем ник пользователя

    // Отправляем сообщение через сокет
    io.emit('telegramMessage', { chatId, name, lastName, username, text: msg.text });
});

// Обработка соединения сокета
io.on('connection', (socket) => {
    console.log('Новое соединение сокета'); // Логируем новое соединение
});

// Авторизация пользователя
app.post('/login', async (req, res) => {
    const { username, password } = req.body; // Получаем логин и пароль из тела запроса

    const user = await User.findOne({ username }); // Ищем пользователя по логину
    if (!user) {
        return res.status(401).json({ message: 'Неверный логин или пароль' }); // Если пользователь не найден, возвращаем ошибку
    }

    const isMatch = await bcrypt.compare(password, user.password); // Сравниваем введенный пароль с хешированным паролем
    if (!isMatch) {
        return res.status(401).json({ message: 'Неверный логин или пароль' }); // Если пароли не совпадают, возвращаем ошибку
    }

    const token = jwt.sign({ id: user._id }, 'your_jwt_secret', { expiresIn: '1h' }); // Генерируем JWT
    res.json({ token }); // Возвращаем токен
});

// Получение данных пользователя
app.get('/user', passport.authenticate('jwt', { session: false }), (req, res) => {
    res.json(req.user); // Возвращаем данные пользователя
});

// Запуск сервера
const PORT = process.env.PORT || 3010; // Устанавливаем порт
server.listen(PORT, () => {
    console.log(`Сервер запущен на порту ${PORT}`); // Выводим сообщение о запуске сервера
});
``````


## Шаг 4: Создание клиентской части

1. Создаем папку `public` и в ней файл `index.html` с следующим содержимым:

``````html
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Messages</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #messages { max-width: 800px; margin: 20px auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f4f4f4; }
        #login { display: block; } /* Показываем форму входа по умолчанию */
        #messagesTable { display: none; } /* Скрываем таблицу сообщений по умолчанию */
    </style>
</head>
<body>
<h1>Сообщения Telegram</h1>
<div id="login">
    <h2>Вход</h2>
    <input type="text" id="username" placeholder="Логин" /> <!-- Поле для ввода логина -->
    <input type="password" id="password" placeholder="Пароль" /> <!-- Поле для ввода пароля -->
    <button onclick="login()">Войти</button> <!-- Кнопка для входа -->
    <p id="loginMessage"></p> <!-- Сообщение об ошибке входа -->
</div>
<table id="messagesTable">
    <thead>
    <tr>
        <th>Chat ID</th>
        <th>Имя</th>
        <th>Фамилия</th>
        <th>Ник</th>
        <th>Сообщение</th>
    </tr>
    </thead>
    <tbody id="messages">
    </tbody>
</table>
<script src="/socket.io/socket.io.js"></script>
<script>
    const socket = io(); // Инициализируем сокет
    let token = ''; // Переменная для хранения токена

    socket.on('connect', () => {
        console.log('Подключено к сокет-серверу'); // Логируем подключение
    });

    socket.on('telegramMessage', (data) => {
        const messagesTable = document.getElementById('messages'); // Получаем таблицу сообщений
        const row = document.createElement('tr'); // Создаем новую строку
        row.innerHTML = `
                <td>${data.chatId}</td>
                <td>${data.name}</td>
                <td>${data.lastName}</td>
                <td>@${data.username}</td>
                <td>${data.text}</td>
            `;
        messagesTable.appendChild(row); // Добавляем строку в таблицу
    });

    function login() {
        const username = document.getElementById('username').value; // Получаем логин
        const password = document.getElementById('password').value; // Получаем пароль

        fetch('/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json', // Устанавливаем заголовок для JSON
            },
            body: JSON.stringify({ username, password }), // Отправляем логин и пароль
        })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Неверный логин или пароль'); // Обрабатываем ошибку
                }
                return response.json(); // Возвращаем JSON
            })
            .then(data => {
                token = data.token; // Сохраняем токен
                document.getElementById('login').style.display = 'none'; // Скрываем форму входа
                document.getElementById('messagesTable').style.display = 'block'; // Показываем таблицу сообщений
                fetchUserData(); // Получаем данные пользователя
            })
            .catch(error => {
                document.getElementById('loginMessage').innerText = error.message; // Выводим сообщение об ошибке
            });
    }

    function fetchUserData() {
        fetch('/user', {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`, // Передаем токен в заголовке
            },
        })
            .then(response => response.json()) // Получаем данные пользователя
            .then(data => {
                console.log('Данные пользователя:', data); // Логируем данные пользователя
            })
            .catch(error => {
                console.error('Ошибка при получении данных пользователя:', error); // Обрабатываем ошибку
            });
    }

    window.onload = function() {
        document.getElementById('login').style.display = 'block'; // Показываем форму входа при загрузке
    };
</script>
</body>
</html>
``````


## Шаг 5: Запуск приложения

1. Убедаемся, что заменили `token` на наш реальный токен Telegram бота.
2. Запускаем сервер:

   ```bash
   node server.js
   ```

3. Открываем браузер и переходим по адресу `http://localhost:3010`. Теперь мы должны увидеть форму для входа. После успешного входа мы сможем видеть сообщения Telegram.

## Общая стратегия по авторизации и хранению паролей

1. **Хранение паролей**: 
   - В нашем коде пароли пользователей не хранятся в явном виде. Вместо этого мы используем библиотеку `bcryptjs` для хеширования паролей перед их сохранением в базе данных. Это означает, что даже если база данных будет скомпрометирована, пароли пользователей останутся защищенными, так как они хранятся в виде хешей, а не в открытом виде.

2. **Генерация пароля**:
   - При первом взаимодействии пользователя с ботом (и при повторной отправке команды /start) генерируется случайный пароль. Этот пароль хешируется и сохраняется в базе данных. Пользователь получает этот пароль в боте Telegram.

3. **Аутентификация**:
   - Для аутентификации пользователей используется библиотека `passport` с стратегией JWT. При входе пользователя проверяется его логин и хешированный пароль. Если они совпадают, создается JWT, который отправляется пользователю. Этот токен используется для авторизации при последующих запросах.

4. **Защита маршрутов**:
   - Для защиты маршрутов, которые требуют аутентификации, используется middleware `passport.authenticate()`. Это позволяет убедиться, что только авторизованные пользователи могут получить доступ к определенным данным, таким как их собственные данные.

Таким образом, мы обеспечиваем безопасность хранения паролей и защищаем доступ к данным пользователей с помощью современных методов аутентификации и хеширования.
