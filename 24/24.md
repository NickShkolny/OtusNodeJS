# Инструкция по созданию серверного приложения на NestJS с использованием TypeORM и PostgreSQL

## Устанавливаем необходимое программное обеспечение

1. **Node.js и npm**: Убедаемся, что у нас установлены Node.js и npm. 

2. **NestJS CLI**: Устанавливаем NestJS CLI глобально, чтобы создать новый проект.
   ```bash
   npm install -g @nestjs/cli
   ```

3. **PostgreSQL**: Устанавливаем PostgreSQL на Ubuntu 20.04.

   ### Установка PostgreSQL на Ubuntu 20.04

   1. Обновляем список пакетов и устанавливаем PostgreSQL.
      ```bash
      sudo apt update
      sudo apt install postgresql postgresql-contrib
      ```

   2. Убеждаемся, что служба PostgreSQL запущена.
      ```bash
      sudo systemctl start postgresql
      sudo systemctl enable postgresql
      ```

   3. Переключаемся на пользователя `postgres` для выполнения команд PostgreSQL.
      ```bash
      sudo -i -u postgres
      ```

   4. Открываем оболочку PostgreSQL.
      ```bash
      psql
      ```

   5. Создаем новую базу данных и пользователя.
      ```sql
      CREATE DATABASE your_database;
      CREATE USER your_username WITH ENCRYPTED PASSWORD 'your_password';
      ```

   6. Даем пользователю права на базу данных.
      ```sql
      GRANT ALL PRIVILEGES ON DATABASE your_database TO your_username;
      ```

   7. Выходим из оболочки PostgreSQL.
      ```sql
      \q
      ```

   8. Выходим из пользователя `postgres`.
      ```bash
      exit
      ```

   ### Настройка доступа к базе данных

   Файл  /etc/postgresql/12/main/pg_hba.conf  используется для настройки доступа к базе данных PostgreSQL. В этом файле вы можете указать, какие IP-адреса имеют доступ к вашей базе данных и какие методы аутентификации использовать.
    Разрешение подключения с любого IP-адреса
    Чтобы разрешить подключение к базе данных PostgreSQL с любого IP-адреса, добавьте следующую строку в файл pg_hba.conf:

    ```bash
    host    all             all             0.0.0.0/0               md5
    ```
    host: Указывает, что это правило для подключения по сети.
    all: Означает, что правило применяется ко всем базам данных.
    all: Означает, что правило применяется ко всем пользователям.
    0.0.0.0/0: Означает, что разрешено подключение с любого IP-адреса.
    md5: Указывает, что для аутентификации используется метод md5 (пароль).
    Разрешение подключения с определенного IP-адреса
    Чтобы разрешить подключение только с определенного IP-адреса, замените 0.0.0.0/0 на конкретный IP-адрес или диапазон IP-адресов. Например, чтобы разрешить доступ только с IP-адреса 192.168.1.100, добавьте следующую строку:
    ```bash
    
    192.168.1.100/32: Означает, что разрешено подключение только с IP-адреса 192.168.1.100.
    ```
    Примечания
    После внесения изменений в файл pg_hba.conf, необходимо перезапустить службу PostgreSQL, чтобы изменения вступили в силу:
    ```bash
    sudo systemctl restart postgresql
    ```
    
    Убедитесь, что в файле конфигурации postgresql.conf параметр listen_addresses настроен на '*', чтобы PostgreSQL слушал подключения на всех интерфейсах:
    
    ```
    listen_addresses = '*'
    ```
    Будьте осторожны при разрешении подключения с любого IP-адреса, так как это может представлять угрозу безопасности. Убедитесь, что у вас настроены надежные пароли и, при необходимости, используйте брандмауэр для ограничения доступа.


   1. Открываем файл конфигурации `pg_hba.conf` для редактирования.
      ```bash
      sudo nano /etc/postgresql/12/main/pg_hba.conf
      ```

   2. Находим строку, начинающуюся с `local` и изменяем метод аутентификации на `md5`.
      ```
      local   all             all                                     md5
      ```

   3. Сохраняем изменения и закрываем редактор (Ctrl + O, Enter, Ctrl + X).

   4. Перезапускаем службу PostgreSQL, чтобы изменения вступили в силу.
      ```bash
      sudo systemctl restart postgresql
      ```

## Создаем новый проект NestJS

1. Создаем новый проект NestJS.
   ```bash
   nest new telegram-bot-app-psql
   ```

2. Переходим в директорию проекта.
   ```bash
   cd telegram-bot-app-psql
   ```

## Устанавливаем зависимости для TypeORM и PostgreSQL

1. Устанавливаем необходимые пакеты для работы с TypeORM и PostgreSQL.
   ```bash
   npm install @nestjs/typeorm typeorm pg
   ```

## Настраиваем подключение к базе данных

1. Открываем файл `src/app.module.ts` и настраиваем подключение к базе данных PostgreSQL.

```typescript

import { Module } from '@nestjs/common'; // Импортируем Module из NestJS
import { TypeOrmModule } from '@nestjs/typeorm'; // Импортируем TypeOrmModule из NestJS
import { AppController } from './app.controller'; // Импортируем контроллер
import { TelegramService } from './telegram/telegram.service'; // Импортируем сервис Telegram
import { User } from './telegram/user.entity'; // Импортируем сущность пользователя

@Module({ // Декорируем класс как модуль
  imports: [
    TypeOrmModule.forRoot({ // Настраиваем подключение к базе данных
      type: 'postgres', // Указываем тип базы данных
      host: 'localhost', // Указываем хост
      port: 5432, // Указываем порт
      username: 'your_username', // Указываем имя пользователя
      password: 'your_password', // Указываем пароль
      database: 'your_database', // Указываем имя базы данных
      entities: [User], // Указываем сущности
      synchronize: true, // Автоматически синхронизируем сущности с базой данных
    }),
    TypeOrmModule.forFeature([User]), // Регистрируем сущность пользователя
  ],
  controllers: [AppController], // Регистрируем контроллер
  providers: [TelegramService], // Регистрируем провайдер
})
export class AppModule {} // Экспортируем модуль

````


## Создаем сущность пользователя

1. Создаем файл `src/telegram/user.entity.ts` и определяем сущность пользователя.

```typescript
import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm'; // Импортируем необходимые декораторы из TypeORM

@Entity() // Декорируем класс как сущность
export class User { // Объявляем класс User
  @PrimaryGeneratedColumn() // Декорируем поле как первичный ключ с автоинкрементом
  id: number; // Идентификатор пользователя

  @Column() // Декорируем поле как колонку
  chatId: number; // Идентификатор чата

  @Column() // Декорируем поле как колонку
  username: string; // Имя пользователя

  @Column() // Декорируем поле как колонку
  firstName: string; // Имя

  @Column() // Декорируем поле как колонку
  lastName: string; // Фамилия

  @Column("text", { array: true }) // Декорируем поле как массив строк
  messages: string[]; // Массив сообщений

  @Column({ nullable: true }) // Декорируем поле как колонку, допускающую null
  phoneNumber: string; // Номер телефона

  @Column("simple-json", { nullable: true }) // Декорируем поле как JSON
  location: { // Объявляем поле location
    type: string; // Тип геометрии
    coordinates: number[]; // Координаты
  };
}
```






## Настраиваем контроллер и сервис

1. Открываем файл `src/app.controller.ts` и настраиваем контроллер.

```typescript

import { Controller, Get } from '@nestjs/common'; // Импортируем необходимые декораторы из NestJS
import { InjectRepository } from '@nestjs/typeorm'; // Импортируем InjectRepository для работы с TypeORM
import { Repository } from 'typeorm'; // Импортируем Repository из TypeORM
import { User } from './telegram/user.entity'; // Импортируем сущность пользователя

@Controller() // Декорируем класс как контроллер
export class AppController { // Объявляем класс AppController
  constructor(@InjectRepository(User) private userRepository: Repository<User>) {} // Внедряем репозиторий пользователя

  @Get('users') // Декорируем метод как GET-эндпоинт
  async getAllUsers() { // Объявляем асинхронный метод getAllUsers
    return this.userRepository.find(); // Возвращаем всех пользователей из базы данных
  }
}
```



2. Открываем файл `src/telegram/telegram.service.ts` и настраиваем сервис.

```typescript

const TELEGRAM_TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN'; // Замените на ваш токен

import { Injectable } from '@nestjs/common'; // Импортируем Injectable из NestJS
import * as TelegramBot from 'node-telegram-bot-api'; // Импортируем TelegramBot
import { InjectRepository } from '@nestjs/typeorm'; // Импортируем InjectRepository для работы с TypeORM
import { Repository } from 'typeorm'; // Импортируем Repository из TypeORM
import { User } from './user.entity'; // Импортируем сущность пользователя
import { Server } from 'socket.io'; // Импортируем Server из socket.io

@Injectable() // Декорируем класс как Injectable
export class TelegramService { // Объявляем класс TelegramService
  private bot: TelegramBot; // Объявляем переменную для бота
  private io: Server; // Объявляем переменную для сервера сокетов

  constructor(@InjectRepository(User) private userRepository: Repository<User>) { // Внедряем репозиторий пользователя
    this.bot = new TelegramBot(TELEGRAM_TOKEN, { polling: true }); // Инициализируем бота

    this.bot.onText(/\/start/, async (msg) => { // Обрабатываем команду /start
      const chatId = msg.chat.id; // Получаем chatId
      const username = msg.from.username; // Получаем имя пользователя
      const firstName = msg.from.first_name; // Получаем имя
      const lastName = msg.from.last_name; // Получаем фамилию

      let user = await this.userRepository.findOne({ where: { chatId } }); // Ищем пользователя в базе данных
      if (!user) { // Если пользователь не найден
        user = this.userRepository.create({ chatId, username, firstName, lastName, messages: [] }); // Создаем нового пользователя
        await this.userRepository.save(user); // Сохраняем пользователя в базе данных
      } else {
        // Обновляем имя, фамилию и юзернейм, если пользователь уже существует
        user.firstName = firstName;
        user.lastName = lastName;
        user.username = username;
        await this.userRepository.save(user); // Сохраняем изменения
      }

      this.bot.sendMessage(chatId, `Привет, ${firstName}! Пожалуйста, отправьте мне Вашу геолокацию и номер телефона.`, { // Отправляем сообщение
        reply_markup: {
          keyboard: [
            [{ text: 'Отправить номер телефона', request_contact: true }], // Кнопка для отправки номера телефона
            [{ text: 'Отправить геолокацию', request_location: true }] // Кнопка для отправки геолокации
          ],
          resize_keyboard: true, // Изменяем размер клавиатуры
          one_time_keyboard: true // Клавиатура исчезает после использования
        }
      });
    });

    this.bot.on('message', async (msg) => { // Обрабатываем входящие сообщения
      const chatId = msg.chat.id; // Получаем chatId
      const text = msg.text; // Получаем текст сообщения

      if (text) {
        const user = await this.userRepository.findOne({ where: { chatId } }); // Ищем пользователя
        if (user) {
          user.messages.push(text); // Добавляем текстовое сообщение в массив
          await this.userRepository.save(user); // Сохраняем изменения
          this.io.emit('updateUser', user); // Отправляем обновленные данные через сокет
        }
      }
    });

    this.bot.on('contact', async (msg) => { // Обрабатываем отправку контакта
      const chatId = msg.chat.id; // Получаем chatId
      const phoneNumber = msg.contact.phone_number; // Получаем номер телефона

      const user = await this.userRepository.findOne({ where: { chatId } }); // Ищем пользователя
      if (user) {
        user.phoneNumber = phoneNumber; // Обновляем номер телефона
        user.messages.push(`Телефон: ${phoneNumber}`); // Добавляем сообщение о телефоне в массив
        await this.userRepository.save(user); // Сохраняем изменения
        this.io.emit('updateUser', user); // Отправляем обновленные данные через сокет
        this.bot.sendMessage(chatId, `Ваш номер телефона записан: ${phoneNumber}`); // Подтверждаем запись номера
      }
    });

    this.bot.on('location', async (msg) => { // Обрабатываем отправку геолокации
      const chatId = msg.chat.id; // Получаем chatId
      const location = msg.location; // Получаем геолокацию

      const user = await this.userRepository.findOne({ where: { chatId } }); // Ищем пользователя
      if (user) {
        user.location = { type: 'Point', coordinates: [location.latitude, location.longitude] }; // Обновляем координаты
        user.messages.push(`Координаты: ${location.latitude}, ${location.longitude}`); // Добавляем сообщение о координатах в массив
        await this.userRepository.save(user); // Сохраняем изменения
        this.io.emit('updateUser', user); // Отправляем обновленные данные через сокет
        this.bot.sendMessage(chatId, `Ваши данные записаны: ${location.latitude}, ${location.longitude}`); // Подтверждаем запись геолокации
      }
    });
  }

  public setSocketServer(io: Server) { // Метод для установки сервера сокетов
    this.io = io; // Присваиваем сервер сокетов
  }
}
```



## Настраиваем WebSocket

1. Открываем файл `src/websocket.gateway.ts` и настраиваем WebSocket.

```typescript
import { WebSocketGateway as NestWebSocketGateway, WebSocketServer, OnGatewayConnection } from '@nestjs/websockets'; // Импортируем необходимые декораторы и классы из NestJS
import { Server } from 'socket.io'; // Импортируем Server из socket.io

@NestWebSocketGateway() // Декорируем класс как WebSocket шлюз
export class WebSocketGateway implements OnGatewayConnection {
  @WebSocketServer() // Декорируем сервер WebSocket
  server: Server; // Объявляем переменную для сервера

  handleConnection(client: any) { // Обрабатываем подключение клиента
    console.log('Client connected'); // Логируем подключение клиента
  }

  sendMessage(message: string) { // Метод для отправки сообщения
    this.server.clients.forEach(client => { // Перебираем всех клиентов
      if (client.readyState === client.OPEN) { // Проверяем, открыт ли клиент
        client.send(message); // Отправляем сообщение
      }
    });
  }
}
```



## Настраиваем HTML файл

1. Создаем файл `public/index.html` и добавляем следующий код:



```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Messages</title>
    <style>
        body { font-family: Arial, sans-serif; }
        #messages { max-width: 800px; margin: 20px auto; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background-color: #f4f4f4; }
    </style>
</head>
<body>
<h1>Сообщения Telegram</h1>
<table>
    <thead>
    <tr>
        <th>Chat ID</th>
        <th>Имя</th>
        <th>Фамилия</th>
        <th>Ник</th>
        <th>Номер телефона</th>
        <th>Последнее сообщение</th>
        <th>Координаты</th>
    </tr>
    </thead>
    <tbody id="messages">
    </tbody>
</table>
<script src="/socket.io/socket.io.js"></script>
<script>
    const socket = io(); // Подключаемся к сокет-серверу

    socket.on('connect', () => { // Обрабатываем событие подключения
        console.log('Подключено к сокет-серверу'); // Логируем подключение
    });

    socket.on('updateUser', (user) => { // Обрабатываем обновление данных пользователя
        updateUserRow(user);
    });

    // Функция для обновления строки пользователя
    function updateUserRow(user) {
        const messagesTable = document.getElementById('messages'); // Получаем таблицу сообщений
        let row = document.getElementById(`user-${user.chatId}`); // Ищем строку пользователя

        if (!row) { // Если строка не найдена
            row = document.createElement('tr'); // Создаем новую строку
            row.id = `user-${user.chatId}`; // Устанавливаем ID строки
            messagesTable.appendChild(row); // Добавляем строку в таблицу
        }

        const lastMessage = user.messages.length > 0 ? user.messages[user.messages.length - 1] : ''; // Получаем последнее сообщение

        // Извлекаем координаты, если они существуют
        const coordinates = user.location && user.location.coordinates && user.location.coordinates.length === 2
            ? `${user.location.coordinates[1]}, ${user.location.coordinates[0]}` //  порядок: [долгота, широта]
            : 'Не указаны';

        row.innerHTML = `
        <td>${user.chatId}</td>
        <td>${user.firstName || ''}</td>
        <td>${user.lastName || ''}</td>
        <td>@${user.username || ''}</td>
        <td>${user.phoneNumber || 'Не указан'}</td>
        <td>${lastMessage}</td>
        <td>${coordinates}</td>
      `;
    }

    // Запрашиваем всех пользователей при загрузке страницы
    window.onload = async () => {
        try {
            const response = await fetch('/users'); // Запрашиваем всех пользователей
            const users = await response.json(); // Парсим ответ в JSON
            users.forEach(user => updateUserRow(user)); // Обновляем таблицу для каждого пользователя
        } catch (error) {
            console.error('Ошибка при загрузке пользователей:', error); // Логируем ошибку
        }
    };
</script>
</body>


```

## Запускаем приложение

1. Запускаем приложение.
   ```bash
   npm run start
   ```

2. Открываем браузер и переходим по адресу `http://localhost:3020`, чтобы увидеть результат.

Теперь у нас есть серверное приложение на NestJS с использованием TypeORM и PostgreSQL, аналогичное нашему приложению на MongoDB. 
