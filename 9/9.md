# Инструкция по созданию приложения на NestJS с использованием MongoDB (Mongoose), Socket.io и Telegram Bot API

## Шаг 1: Установка необходимых пакетов

1. Создаем новую директорию для вашего проекта и переходим в нее:

   ```bash
   mkdir telegram-socket-nest-app
   cd telegram-socket-nest-app
   ```

2. Инициализируем проект NestJS:

   ```bash
   nest new telegram-socket-nest-app
   ```

3. Устанавливаем необходимые пакеты:

   ```bash
   cd telegram-socket-nest-app
   npm install socket.io node-telegram-bot-api @nestjs/platform-express mongoose @nestjs/mongoose
   ```

## Шаг 2: Настройка схемы пользователя

1. Создаем файл `src/telegram/user.schema.ts` и добавляем следующий код:

   ````typescript
   import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose'; // Импортируем необходимые декораторы и функции из Mongoose
   import { Document } from 'mongoose'; // Импортируем Document из Mongoose

   @Schema() // Декорируем класс как схему
   export class User extends Document { // Наследуем от Document для работы с Mongoose
     @Prop() // Декорируем поле как свойство схемы
     chatId: number; // Идентификатор чата

     @Prop() // Декорируем поле как свойство схемы
     username: string; // Имя пользователя

     @Prop() // Декорируем поле как свойство схемы
     firstName: string; // Имя

     @Prop() // Декорируем поле как свойство схемы
     lastName: string; // Фамилия

     @Prop([String]) // Декорируем поле как массив строк
     messages: string[]; // Массив сообщений

     @Prop() // Декорируем поле как свойство схемы
     phoneNumber: string; // Номер телефона

     @Prop({
       type: { type: String, default: 'Point' }, // Тип геометрии
       coordinates: { type: [Number], default: undefined } // Координаты
     })
     location: { // Объявляем поле location
       type: string; // Тип геометрии
       coordinates: number[]; // Координаты
     };
   }

   export const UserSchema = SchemaFactory.createForClass(User); // Создаем схему из класса
   ````

## Шаг 3: Настройка контроллера

1. Создаем файл `src/app.controller.ts` и добавляем следующий код:

   ````typescript
   import { Controller, Get } from '@nestjs/common'; // Импортируем необходимые декораторы из NestJS
   import { InjectModel } from '@nestjs/mongoose'; // Импортируем InjectModel для работы с Mongoose
   import { Model } from 'mongoose'; // Импортируем Model из Mongoose
   import { User } from './telegram/user.schema'; // Импортируем схему пользователя

   @Controller() // Декорируем класс как контроллер
   export class AppController {
     constructor(@InjectModel(User.name) private userModel: Model<User>) {} // Внедряем модель пользователя

     @Get('users') // Декорируем метод как GET-эндпоинт
     async getAllUsers() {
       return this.userModel.find().exec(); // Возвращаем всех пользователей из базы данных
     }
   }
   ````

## Шаг 4: Настройка Telegram бота

1. Создаем файл `src/telegram/telegram.service.ts` и добавляем следующий код:

   ````typescript
   import { Injectable } from '@nestjs/common'; // Импортируем Injectable из NestJS
   import * as TelegramBot from 'node-telegram-bot-api'; // Импортируем TelegramBot
   import { InjectModel } from '@nestjs/mongoose'; // Импортируем InjectModel для работы с Mongoose
   import { Model } from 'mongoose'; // Импортируем Model из Mongoose
   import { User } from './user.schema'; // Импортируем схему пользователя
   import { Server } from 'socket.io'; // Импортируем Server из socket.io

   @Injectable() // Декорируем класс как Injectable
   export class TelegramService {
     private bot: TelegramBot; // Объявляем переменную для бота
     private io: Server; // Объявляем переменную для сервера сокетов

     constructor(@InjectModel(User.name) private userModel: Model<User>) { // Внедряем модель пользователя
       const TELEGRAM_TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN'; // ЗАМЕНЯЕМ НА НАШ ТОКЕН!!!!!!
       this.bot = new TelegramBot(TELEGRAM_TOKEN, { polling: true }); // Инициализируем бота

       this.bot.onText(/\/start/, async (msg) => { // Обрабатываем команду /start
         const chatId = msg.chat.id; // Получаем chatId
         const username = msg.from.username; // Получаем имя пользователя
         const firstName = msg.from.first_name; // Получаем имя
         const lastName = msg.from.last_name; // Получаем фамилию

         const user = await this.userModel.findOne({ chatId }); // Ищем пользователя в базе данных
         if (!user) { // Если пользователь не найден
           await this.userModel.create({ chatId, username, firstName, lastName, messages: [] }); // Создаем нового пользователя
         } else {
           // Обновляем имя и фамилию, если пользователь уже существует
           await this.userModel.updateOne({ chatId }, { firstName, lastName });
         }

         this.bot.sendMessage(chatId, `Здравствуйте, ${username}! Пожалуйста, отправьте мне Вашу геолокацию и номер телефона.`, { // Отправляем сообщение
           reply_markup: {
             keyboard: [
               [{ text: 'Отправить номер телефона', request_contact: true }], // Кнопка для отправки номера телефона
               [{ text: 'Отправить геолокацию', request_location: true }] // Кнопка для отправки геолокации
             ],
             resize_keyboard: true, // Изменяем размер клавиатуры
             one_time_keyboard: true // Клавиатура исчезает после использования
           }
         });
       });

       this.bot.on('message', async (msg) => { // Обрабатываем входящие сообщения
         const chatId = msg.chat.id; // Получаем chatId
         const text = msg.text; // Получаем текст сообщения

         if (text) {
           await this.userModel.updateOne({ chatId }, { $push: { messages: text } }); // Добавляем текстовое сообщение в массив
         }

         const updatedUser = await this.userModel.findOne({ chatId }); // Получаем обновленного пользователя
         this.io.emit('updateUser', updatedUser); // Отправляем обновленные данные через сокет
       });

       this.bot.on('contact', async (msg) => { // Обрабатываем отправку контакта
         const chatId = msg.chat.id; // Получаем chatId
         const phoneNumber = msg.contact.phone_number; // Получаем номер телефона

         await this.userModel.updateOne(
           { chatId },
           {
             phoneNumber,
             $push: { messages: `Телефон: ${phoneNumber}` } // Добавляем сообщение о телефоне в массив
           }
         );

         const updatedUser = await this.userModel.findOne({ chatId }); // Получаем обновленного пользователя
         this.io.emit('updateUser', updatedUser); // Отправляем обновленные данные через сокет

         this.bot.sendMessage(chatId, `Ваш номер телефона записан: ${phoneNumber}`); // Подтверждаем запись номера
       });

       this.bot.on('location', async (msg) => { // Обрабатываем отправку геолокации
         const chatId = msg.chat.id; // Получаем chatId
         const location = msg.location; // Получаем геолокацию

         await this.userModel.updateOne(
           { chatId },
           {
             location: { type: 'Point', coordinates: [location.latitude, location.longitude] }, // Обновляем координаты
             $push: { messages: `Координаты: ${location.latitude}, ${location.longitude}` } // Добавляем сообщение о координатах в массив
           }
         );

         const updatedUser = await this.userModel.findOne({ chatId }); // Получаем обновленного пользователя
         this.io.emit('updateUser', updatedUser); // Отправляем обновленные данные через сокет

         this.bot.sendMessage(chatId, `Ваши данные записаны: ${location.latitude}, ${location.longitude}`); // Подтверждаем запись геолокации
       });
     }

     public setSocketServer(io: Server) { // Метод для установки сервера сокетов
       this.io = io; // Присваиваем сервер сокетов
     }
   }
   ````

## Шаг 5: Настройка основного файла приложения

1. Обновляем файл `src/main.ts`:

   ````typescript
   import { NestFactory } from '@nestjs/core'; // Импортируем NestFactory из NestJS
   import { AppModule } from './app.module'; // Импортируем модуль приложения
   import { NestExpressApplication } from '@nestjs/platform-express'; // Импортируем NestExpressApplication
   import { join } from 'path'; // Импортируем join из path
   import { Server } from 'socket.io'; // Импортируем Server из socket.io
   import { TelegramService } from './telegram/telegram.service'; // Импортируем сервис Telegram

   async function bootstrap() { // Объявляем асинхронную функцию bootstrap
     const app = await NestFactory.create<NestExpressApplication>(AppModule); // Создаем приложение NestJS

     app.useStaticAssets(join(__dirname, '..', 'public')); // Настраиваем директорию для статических файлов

     const server = app.getHttpServer(); // Получаем HTTP-сервер
     const io = new Server(server); // Создаем сервер сокетов

     const telegramService = app.get(TelegramService); // Получаем сервис Telegram
     telegramService.setSocketServer(io); // Устанавливаем сервер сокетов

     io.on('connection', (socket) => { // Обрабатываем подключение сокета
       console.log('Новое соединение сокета'); // Логируем подключение
     });

     await app.listen(3010); // Запускаем приложение на порту 3010
     console.log(`Сервер запущен на http://localhost:3010`); // Логируем запуск сервера
   }
   bootstrap(); // Вызываем функцию bootstrap
   ````

## Шаг 6: Создание клиентской части

1. Создаем папку `public` и в ней файл `index.html` с следующим содержимым:

   ````html
   <!-- public/index.html -->
   <!DOCTYPE html>
   <html lang="en">
   <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Telegram Messages</title>
     <style>
       body { font-family: Arial, sans-serif; }
       #messages { max-width: 800px; margin: 20px auto; }
       table { width: 100%; border-collapse: collapse; }
       th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
       th { background-color: #f4f4f4; }
     </style>
   </head>
   <body>
     <h1>Сообщения Telegram</h1>
     <table>
       <thead>
         <tr>
           <th>Chat ID</th>
           <th>Имя</th>
           <th>Фамилия</th>
           <th>Ник</th>
           <th>Номер телефона</th>
           <th>Последнее сообщение</th>
           <th>Координаты</th>
         </tr>
       </thead>
       <tbody id="messages">
       </tbody>
     </table>
     <script src="/socket.io/socket.io.js"></script>
     <script>
       const socket = io(); // Подключаемся к сокет-серверу

       socket.on('connect', () => { // Обрабатываем событие подключения
         console.log('Подключено к сокет-серверу'); // Логируем подключение
       });

       socket.on('updateUser', (user) => { // Обрабатываем обновление данных пользователя
         updateUserRow(user);
       });

       // Функция для обновления строки пользователя
       function updateUserRow(user) {
         const messagesTable = document.getElementById('messages'); // Получаем таблицу сообщений
         let row = document.getElementById(`user-${user.chatId}`); // Ищем строку пользователя

         if (!row) { // Если строка не найдена
           row = document.createElement('tr'); // Создаем новую строку
           row.id = `user-${user.chatId}`; // Устанавливаем ID строки
           messagesTable.appendChild(row); // Добавляем строку в таблицу
         }

         const lastMessage = user.messages.length > 0 ? user.messages[user.messages.length - 1] : ''; // Получаем последнее сообщение

         // Извлекаем координаты, если они существуют
         const coordinates = user.location && user.location.coordinates && user.location.coordinates.length === 2
           ? `${user.location.coordinates[1]}, ${user.location.coordinates[0]}` // Обратите внимание на порядок: [долгота, широта]
           : 'Не указаны';

         row.innerHTML = `
           <td>${user.chatId}</td>
           <td>${user.firstName || ''}</td>
           <td>${user.lastName || ''}</td>
           <td>@${user.username || ''}</td>
           <td>${user.phoneNumber || 'Не указан'}</td>
           <td>${lastMessage}</td>
           <td>${coordinates}</td>
         `;
       }

       // Запрашиваем всех пользователей при загрузке страницы
       window.onload = async () => {
         try {
           const response = await fetch('/users'); // Запрашиваем всех пользователей
           const users = await response.json(); // Парсим ответ в JSON
           users.forEach(user => updateUserRow(user)); // Обновляем таблицу для каждого пользователя
         } catch (error) {
           console.error('Ошибка при загрузке пользователей:', error); // Логируем ошибку
         }
       };
     </script>
   </body>
   </html>
   ````

## Шаг 7: Запуск приложения

1. Убеждаемся, что заменили `YOUR_TELEGRAM_BOT_TOKEN` на наш реальный токен Telegram бота.
2. Запускаем сервер:

   ```bash
   npm run start
   ```

3. Открываем браузер и переходим по адресу `http://localhost:3010`. Теперь мы должны видеть в реальном времени изменяющуюся таблицу, в которой отображаются ID чатов, имена, фамилии, ники телеграм и номера телефонов пользователей,а так же их последние сообщения, отправленные нашему Telegram боту.

